"format amd";
(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var getOwnPropertyDescriptor = true;
  try {
    Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
  }
  catch(e) {
    getOwnPropertyDescriptor = false;
  }

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  function register(name, deps, declare) {
    if (arguments.length === 4)
      return registerDynamic.apply(this, arguments);
    doRegister(name, {
      declarative: true,
      deps: deps,
      declare: declare
    });
  }

  function registerDynamic(name, deps, executingRequire, execute) {
    doRegister(name, {
      declarative: false,
      deps: deps,
      executingRequire: executingRequire,
      execute: execute
    });
  }

  function doRegister(name, entry) {
    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry;

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }


  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative;
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          for (var j = 0; j < importerModule.dependencies.length; ++j) {
            if (importerModule.dependencies[j] === module) {
              importerModule.setters[j](exports);
            }
          }
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;

    if (exports && exports.__esModule) {
      entry.esModule = exports;
    }
    else {
      entry.esModule = {};

      // don't trigger getters/setters in environments that support them
      if ((typeof exports == 'object' || typeof exports == 'function') && exports !== global) {
        if (getOwnPropertyDescriptor) {
          var d;
          for (var p in exports)
            if (d = Object.getOwnPropertyDescriptor(exports, p))
              defineProperty(entry.esModule, p, d);
        }
        else {
          var hasOwnProperty = exports && exports.hasOwnProperty;
          for (var p in exports) {
            if (!hasOwnProperty || exports.hasOwnProperty(p))
              entry.esModule[p] = exports[p];
          }
         }
       }
      entry.esModule['default'] = exports;
      defineProperty(entry.esModule, '__useDefault', {
        value: true
      });
    }
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    // node core modules
    if (name.substr(0, 6) == '@node/')
      return require(name.substr(6));

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    // exported modules get __esModule defined for interop
    if (entry.declarative)
      defineProperty(entry.module.exports, '__esModule', { value: true });

    // return the defined module object
    return modules[name] = entry.declarative ? entry.module.exports : entry.esModule;
  };

  return function(mains, depNames, declare) {
    return function(formatDetect) {
      formatDetect(function(deps) {
        var System = {
          _nodeRequire: typeof require != 'undefined' && require.resolve && typeof process != 'undefined' && require,
          register: register,
          registerDynamic: registerDynamic,
          get: load,
          set: function(name, module) {
            modules[name] = module;
          },
          newModule: function(module) {
            return module;
          }
        };
        System.set('@empty', {});

        // register external dependencies
        for (var i = 0; i < depNames.length; i++) (function(depName, dep) {
          if (dep && dep.__esModule)
            System.register(depName, [], function(_export) {
              return {
                setters: [],
                execute: function() {
                  for (var p in dep)
                    if (p != '__esModule' && !(typeof p == 'object' && p + '' == 'Module'))
                      _export(p, dep[p]);
                }
              };
            });
          else
            System.registerDynamic(depName, [], false, function() {
              return dep;
            });
        })(depNames[i], arguments[i]);

        // register modules in this bundle
        declare(System);

        // load mains
        var firstLoad = load(mains[0]);
        if (mains.length > 1)
          for (var i = 1; i < mains.length; i++)
            load(mains[i]);

        if (firstLoad.__useDefault)
          return firstLoad['default'];
        else
          return firstLoad;
      });
    };
  };

})(typeof self != 'undefined' ? self : global)
/* (['mainModule'], ['external-dep'], function($__System) {
  System.register(...);
})
(function(factory) {
  if (typeof define && define.amd)
    define(['external-dep'], factory);
  // etc UMD / module pattern
})*/

(['1'], [], function($__System) {

$__System.registerDynamic("2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3", ["2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4", ["3"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : req('3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5", ["4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('4');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6", ["5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(window, undefined) {
      'use strict';
      var counter = 0;
      var doc = isHostType(window, 'document') && document;
      var freeDefine = typeof define == 'function' && typeof define.amd == 'object' && define.amd && define;
      var freeExports = typeof exports == 'object' && exports && (typeof global == 'object' && global && global == global.global && (window = global), exports);
      var freeRequire = typeof req == 'function' && req;
      var getAllKeys = Object.getOwnPropertyNames;
      var getDescriptor = Object.getOwnPropertyDescriptor;
      var hasOwnProperty = {}.hasOwnProperty;
      var isExtensible = Object.isExtensible || function() {
        return true;
      };
      var microtimeObject = req('microtime');
      var perfObject = isHostType(window, 'performance') && performance;
      var perfName = perfObject && (perfObject.now && 'now' || perfObject.webkitNow && 'webkitNow');
      var processObject = isHostType(window, 'process') && process;
      var propertyIsEnumerable = {}.propertyIsEnumerable;
      var setDescriptor = Object.defineProperty;
      var toString = {}.toString;
      var trash = doc && doc.createElement('div');
      var uid = 'uid' + (+new Date);
      var calledBy = {};
      var divisors = {
        '1': 4096,
        '2': 512,
        '3': 64,
        '4': 8,
        '5': 0
      };
      var tTable = {
        '1': 12.706,
        '2': 4.303,
        '3': 3.182,
        '4': 2.776,
        '5': 2.571,
        '6': 2.447,
        '7': 2.365,
        '8': 2.306,
        '9': 2.262,
        '10': 2.228,
        '11': 2.201,
        '12': 2.179,
        '13': 2.16,
        '14': 2.145,
        '15': 2.131,
        '16': 2.12,
        '17': 2.11,
        '18': 2.101,
        '19': 2.093,
        '20': 2.086,
        '21': 2.08,
        '22': 2.074,
        '23': 2.069,
        '24': 2.064,
        '25': 2.06,
        '26': 2.056,
        '27': 2.052,
        '28': 2.048,
        '29': 2.045,
        '30': 2.042,
        'infinity': 1.96
      };
      var uTable = {
        '5': [0, 1, 2],
        '6': [1, 2, 3, 5],
        '7': [1, 3, 5, 6, 8],
        '8': [2, 4, 6, 8, 10, 13],
        '9': [2, 4, 7, 10, 12, 15, 17],
        '10': [3, 5, 8, 11, 14, 17, 20, 23],
        '11': [3, 6, 9, 13, 16, 19, 23, 26, 30],
        '12': [4, 7, 11, 14, 18, 22, 26, 29, 33, 37],
        '13': [4, 8, 12, 16, 20, 24, 28, 33, 37, 41, 45],
        '14': [5, 9, 13, 17, 22, 26, 31, 36, 40, 45, 50, 55],
        '15': [5, 10, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64],
        '16': [6, 11, 15, 21, 26, 31, 37, 42, 47, 53, 59, 64, 70, 75],
        '17': [6, 11, 17, 22, 28, 34, 39, 45, 51, 57, 63, 67, 75, 81, 87],
        '18': [7, 12, 18, 24, 30, 36, 42, 48, 55, 61, 67, 74, 80, 86, 93, 99],
        '19': [7, 13, 19, 25, 32, 38, 45, 52, 58, 65, 72, 78, 85, 92, 99, 106, 113],
        '20': [8, 14, 20, 27, 34, 41, 48, 55, 62, 69, 76, 83, 90, 98, 105, 112, 119, 127],
        '21': [8, 15, 22, 29, 36, 43, 50, 58, 65, 73, 80, 88, 96, 103, 111, 119, 126, 134, 142],
        '22': [9, 16, 23, 30, 38, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125, 133, 141, 150, 158],
        '23': [9, 17, 24, 32, 40, 48, 56, 64, 73, 81, 89, 98, 106, 115, 123, 132, 140, 149, 157, 166, 175],
        '24': [10, 17, 25, 33, 42, 50, 59, 67, 76, 85, 94, 102, 111, 120, 129, 138, 147, 156, 165, 174, 183, 192],
        '25': [10, 18, 27, 35, 44, 53, 62, 71, 80, 89, 98, 107, 117, 126, 135, 145, 154, 163, 173, 182, 192, 201, 211],
        '26': [11, 19, 28, 37, 46, 55, 64, 74, 83, 93, 102, 112, 122, 132, 141, 151, 161, 171, 181, 191, 200, 210, 220, 230],
        '27': [11, 20, 29, 38, 48, 57, 67, 77, 87, 97, 107, 118, 125, 138, 147, 158, 168, 178, 188, 199, 209, 219, 230, 240, 250],
        '28': [12, 21, 30, 40, 50, 60, 70, 80, 90, 101, 111, 122, 132, 143, 154, 164, 175, 186, 196, 207, 218, 228, 239, 250, 261, 272],
        '29': [13, 22, 32, 42, 52, 62, 73, 83, 94, 105, 116, 127, 138, 149, 160, 171, 182, 193, 204, 215, 226, 238, 249, 260, 271, 282, 294],
        '30': [13, 23, 33, 43, 54, 65, 76, 87, 98, 109, 120, 131, 143, 154, 166, 177, 189, 200, 212, 223, 235, 247, 258, 270, 282, 293, 305, 317]
      };
      var support = {};
      (function() {
        support.air = isClassOf(window.runtime, 'ScriptBridgingProxyObject');
        support.argumentsClass = isClassOf(arguments, 'Arguments');
        support.browser = doc && isHostType(window, 'navigator');
        support.charByIndex = ('x'[0] + Object('x')[0]) == 'xx';
        support.charByOwnIndex = support.charByIndex && hasKey('x', '0');
        support.java = isClassOf(window.java, 'JavaPackage');
        support.timeout = isHostType(window, 'setTimeout') && isHostType(window, 'clearTimeout');
        try {
          support.decompilation = Function('return (' + (function(x) {
            return {
              'x': '' + (1 + x) + '',
              'y': 0
            };
          }) + ')')()(0).x === '1';
        } catch (e) {
          support.decompilation = false;
        }
        try {
          var o = {};
          support.descriptors = (setDescriptor(o, o, o), 'value' in getDescriptor(o, o));
        } catch (e) {
          support.descriptors = false;
        }
        try {
          support.getAllKeys = /\bvalueOf\b/.test(getAllKeys(Object.prototype));
        } catch (e) {
          support.getAllKeys = false;
        }
        support.iteratesOwnFirst = (function() {
          var props = [];
          function ctor() {
            this.x = 1;
          }
          ctor.prototype = {'y': 1};
          for (var prop in new ctor) {
            props.push(prop);
          }
          return props[0] == 'x';
        }());
        try {
          support.nodeClass = ({'toString': 0} + '', toString.call(doc || 0) != '[object Object]');
        } catch (e) {
          support.nodeClass = true;
        }
      }());
      var timer = {
        'ns': Date,
        'start': null,
        'stop': null
      };
      var noArgumentsClass = !support.argumentsClass,
          noCharByIndex = !support.charByIndex,
          noCharByOwnIndex = !support.charByOwnIndex;
      var abs = Math.abs,
          floor = Math.floor,
          max = Math.max,
          min = Math.min,
          pow = Math.pow,
          sqrt = Math.sqrt;
      function Benchmark(name, fn, options) {
        var me = this;
        if (me == null || me.constructor != Benchmark) {
          return new Benchmark(name, fn, options);
        }
        if (isClassOf(name, 'Object')) {
          options = name;
        } else if (isClassOf(name, 'Function')) {
          options = fn;
          fn = name;
        } else if (isClassOf(fn, 'Object')) {
          options = fn;
          fn = null;
          me.name = name;
        } else {
          me.name = name;
        }
        setOptions(me, options);
        me.id || (me.id = ++counter);
        me.fn == null && (me.fn = fn);
        me.stats = deepClone(me.stats);
        me.times = deepClone(me.times);
      }
      function Deferred(clone) {
        var me = this;
        if (me == null || me.constructor != Deferred) {
          return new Deferred(clone);
        }
        me.benchmark = clone;
        clock(me);
      }
      function Event(type) {
        var me = this;
        return (me == null || me.constructor != Event) ? new Event(type) : (type instanceof Event) ? type : extend(me, {'timeStamp': +new Date}, typeof type == 'string' ? {'type': type} : type);
      }
      function Suite(name, options) {
        var me = this;
        if (me == null || me.constructor != Suite) {
          return new Suite(name, options);
        }
        if (isClassOf(name, 'Object')) {
          options = name;
        } else {
          me.name = name;
        }
        setOptions(me, options);
      }
      function concat() {
        var value,
            j = -1,
            length = arguments.length,
            result = slice.call(this),
            index = result.length;
        while (++j < length) {
          value = arguments[j];
          if (isClassOf(value, 'Array')) {
            for (var k = 0,
                l = value.length; k < l; k++, index++) {
              if (k in value) {
                result[index] = value[k];
              }
            }
          } else {
            result[index++] = value;
          }
        }
        return result;
      }
      function insert(start, deleteCount, elements) {
        var deleteEnd = start + deleteCount,
            elementCount = elements ? elements.length : 0,
            index = start - 1,
            length = start + elementCount,
            object = this,
            result = Array(deleteCount),
            tail = slice.call(object, deleteEnd);
        while (++index < deleteEnd) {
          if (index in object) {
            result[index - start] = object[index];
            delete object[index];
          }
        }
        index = start - 1;
        while (++index < length) {
          object[index] = elements[index - start];
        }
        start = index--;
        length = max(0, (object.length >>> 0) - deleteCount + elementCount);
        while (++index < length) {
          if ((index - start) in tail) {
            object[index] = tail[index - start];
          } else if (index in object) {
            delete object[index];
          }
        }
        deleteCount = deleteCount > elementCount ? deleteCount - elementCount : 0;
        while (deleteCount--) {
          index = length + deleteCount;
          if (index in object) {
            delete object[index];
          }
        }
        object.length = length;
        return result;
      }
      function reverse() {
        var upperIndex,
            value,
            index = -1,
            object = Object(this),
            length = object.length >>> 0,
            middle = floor(length / 2);
        if (length > 1) {
          while (++index < middle) {
            upperIndex = length - index - 1;
            value = upperIndex in object ? object[upperIndex] : uid;
            if (index in object) {
              object[upperIndex] = object[index];
            } else {
              delete object[upperIndex];
            }
            if (value != uid) {
              object[index] = value;
            } else {
              delete object[index];
            }
          }
        }
        return object;
      }
      function shift() {
        return insert.call(this, 0, 1)[0];
      }
      function slice(start, end) {
        var index = -1,
            object = Object(this),
            length = object.length >>> 0,
            result = [];
        start = toInteger(start);
        start = start < 0 ? max(length + start, 0) : min(start, length);
        start--;
        end = end == null ? length : toInteger(end);
        end = end < 0 ? max(length + end, 0) : min(end, length);
        while ((++index, ++start) < end) {
          if (start in object) {
            result[index] = object[start];
          }
        }
        return result;
      }
      function splice(start, deleteCount) {
        var object = Object(this),
            length = object.length >>> 0;
        start = toInteger(start);
        start = start < 0 ? max(length + start, 0) : min(start, length);
        deleteCount = arguments.length == 1 ? length - start : min(max(toInteger(deleteCount), 0), length - start);
        return insert.call(object, start, deleteCount, slice.call(arguments, 2));
      }
      function toInteger(value) {
        value = +value;
        return value === 0 || !isFinite(value) ? value || 0 : value - (value % 1);
      }
      function unshift() {
        var object = Object(this);
        insert.call(object, 0, 0, arguments);
        return object.length;
      }
      function bind(fn, thisArg) {
        return function() {
          fn.apply(thisArg, arguments);
        };
      }
      function createFunction() {
        createFunction = function(args, body) {
          var result,
              anchor = freeDefine ? define.amd : Benchmark,
              prop = uid + 'createFunction';
          runScript((freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '=function(' + args + '){' + body + '}');
          result = anchor[prop];
          delete anchor[prop];
          return result;
        };
        createFunction = support.browser && (createFunction('', 'return"' + uid + '"') || noop)() == uid ? createFunction : Function;
        return createFunction.apply(null, arguments);
      }
      function delay(bench, fn) {
        bench._timerId = setTimeout(fn, bench.delay * 1e3);
      }
      function destroyElement(element) {
        trash.appendChild(element);
        trash.innerHTML = '';
      }
      function forProps() {
        var forShadowed,
            skipSeen,
            forArgs = true,
            shadowed = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
        (function(enumFlag, key) {
          function Klass() {
            this.valueOf = 0;
          }
          ;
          Klass.prototype.valueOf = 0;
          for (key in new Klass) {
            enumFlag += key == 'valueOf' ? 1 : 0;
          }
          for (key in arguments) {
            key == '0' && (forArgs = false);
          }
          skipSeen = enumFlag == 2;
          forShadowed = !enumFlag;
        }(0));
        forProps = function(object, callback, options) {
          options || (options = {});
          var result = object;
          object = Object(object);
          var ctor,
              key,
              keys,
              skipCtor,
              done = !result,
              which = options.which,
              allFlag = which == 'all',
              index = -1,
              iteratee = object,
              length = object.length,
              ownFlag = allFlag || which == 'own',
              seen = {},
              skipProto = isClassOf(object, 'Function'),
              thisArg = options.bind;
          if (thisArg !== undefined) {
            callback = bind(callback, thisArg);
          }
          if (allFlag && support.getAllKeys) {
            for (index = 0, keys = getAllKeys(object), length = keys.length; index < length; index++) {
              key = keys[index];
              if (callback(object[key], key, object) === false) {
                break;
              }
            }
          } else {
            for (key in object) {
              if ((done = !(skipProto && key == 'prototype') && !(skipSeen && (hasKey(seen, key) || !(seen[key] = true))) && (!ownFlag || ownFlag && hasKey(object, key)) && callback(object[key], key, object) === false)) {
                break;
              }
            }
            if (!done && (forArgs && isArguments(object) || ((noCharByIndex || noCharByOwnIndex) && isClassOf(object, 'String') && (iteratee = noCharByIndex ? object.split('') : object)))) {
              while (++index < length) {
                if ((done = callback(iteratee[index], String(index), object) === false)) {
                  break;
                }
              }
            }
            if (!done && forShadowed) {
              ctor = object.constructor;
              skipCtor = ctor && ctor.prototype && ctor.prototype.constructor === ctor;
              for (index = 0; index < 7; index++) {
                key = shadowed[index];
                if (!(skipCtor && key == 'constructor') && hasKey(object, key) && callback(object[key], key, object) === false) {
                  break;
                }
              }
            }
          }
          return result;
        };
        return forProps.apply(null, arguments);
      }
      function getFirstArgument(fn) {
        return (!hasKey(fn, 'toString') && (/^[\s(]*function[^(]*\(([^\s,)]+)/.exec(fn) || 0)[1]) || '';
      }
      function getMean(sample) {
        return reduce(sample, function(sum, x) {
          return sum + x;
        }) / sample.length || 0;
      }
      function getSource(fn, altSource) {
        var result = altSource;
        if (isStringable(fn)) {
          result = String(fn);
        } else if (support.decompilation) {
          result = (/^[^{]+\{([\s\S]*)}\s*$/.exec(fn) || 0)[1];
        }
        result = (result || '').replace(/^\s+|\s+$/g, '');
        return /^(?:\/\*+[\w|\W]*?\*\/|\/\/.*?[\n\r\u2028\u2029]|\s)*(["'])use strict\1;?$/.test(result) ? '' : result;
      }
      function isArguments() {
        isArguments = function(value) {
          return toString.call(value) == '[object Arguments]';
        };
        if (noArgumentsClass) {
          isArguments = function(value) {
            return hasKey(value, 'callee') && !(propertyIsEnumerable && propertyIsEnumerable.call(value, 'callee'));
          };
        }
        return isArguments(arguments[0]);
      }
      function isClassOf(value, name) {
        return value != null && toString.call(value) == '[object ' + name + ']';
      }
      function isHostType(object, property) {
        var type = object != null ? typeof object[property] : 'number';
        return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == 'object' ? !!object[property] : true);
      }
      function isPlainObject(value) {
        var result = false;
        if (!(value && typeof value == 'object') || (noArgumentsClass && isArguments(value))) {
          return result;
        }
        var ctor = value.constructor;
        if ((support.nodeClass || !(typeof value.toString != 'function' && typeof(value + '') == 'string')) && (!isClassOf(ctor, 'Function') || ctor instanceof ctor)) {
          if (support.iteratesOwnFirst) {
            forProps(value, function(subValue, subKey) {
              result = subKey;
            });
            return result === false || hasKey(value, result);
          }
          forProps(value, function(subValue, subKey) {
            result = !hasKey(value, subKey);
            return false;
          });
          return result === false;
        }
        return result;
      }
      function isStringable(value) {
        return hasKey(value, 'toString') || isClassOf(value, 'String');
      }
      function methodize(fn) {
        return function() {
          var args = [this];
          args.push.apply(args, arguments);
          return fn.apply(null, args);
        };
      }
      function noop() {}
      function req(id) {
        try {
          var result = freeExports && freeRequire(id);
        } catch (e) {}
        return result || null;
      }
      function runScript(code) {
        var anchor = freeDefine ? define.amd : Benchmark,
            script = doc.createElement('script'),
            sibling = doc.getElementsByTagName('script')[0],
            parent = sibling.parentNode,
            prop = uid + 'runScript',
            prefix = '(' + (freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '||function(){})();';
        try {
          script.appendChild(doc.createTextNode(prefix + code));
          anchor[prop] = function() {
            destroyElement(script);
          };
        } catch (e) {
          parent = parent.cloneNode(false);
          sibling = null;
          script.text = code;
        }
        parent.insertBefore(script, sibling);
        delete anchor[prop];
      }
      function setOptions(bench, options) {
        options = extend({}, bench.constructor.options, options);
        bench.options = forOwn(options, function(value, key) {
          if (value != null) {
            if (/^on[A-Z]/.test(key)) {
              forEach(key.split(' '), function(key) {
                bench.on(key.slice(2).toLowerCase(), value);
              });
            } else if (!hasKey(bench, key)) {
              bench[key] = deepClone(value);
            }
          }
        });
      }
      function resolve() {
        var me = this,
            clone = me.benchmark,
            bench = clone._original;
        if (bench.aborted) {
          me.teardown();
          clone.running = false;
          cycle(me);
        } else if (++me.cycles < clone.count) {
          if (support.timeout) {
            setTimeout(function() {
              clone.compiled.call(me, timer);
            }, 0);
          } else {
            clone.compiled.call(me, timer);
          }
        } else {
          timer.stop(me);
          me.teardown();
          delay(clone, function() {
            cycle(me);
          });
        }
      }
      function deepClone(value) {
        var accessor,
            circular,
            clone,
            ctor,
            descriptor,
            extensible,
            key,
            length,
            markerKey,
            parent,
            result,
            source,
            subIndex,
            data = {'value': value},
            index = 0,
            marked = [],
            queue = {'length': 0},
            unmarked = [];
        function Marker(object) {
          this.raw = object;
        }
        function forPropsCallback(subValue, subKey) {
          if (subValue && subValue.constructor == Marker) {
            return;
          }
          if (subValue === Object(subValue)) {
            queue[queue.length++] = {
              'key': subKey,
              'parent': clone,
              'source': value
            };
          } else {
            try {
              clone[subKey] = subValue;
            } catch (e) {}
          }
        }
        function getMarkerKey(object) {
          var result = uid;
          while (object[result] && object[result].constructor != Marker) {
            result += 1;
          }
          return result;
        }
        do {
          key = data.key;
          parent = data.parent;
          source = data.source;
          clone = value = source ? source[key] : data.value;
          accessor = circular = descriptor = false;
          if (value === Object(value)) {
            if (isClassOf(value.deepClone, 'Function')) {
              clone = value.deepClone();
            } else {
              ctor = value.constructor;
              switch (toString.call(value)) {
                case '[object Array]':
                  clone = new ctor(value.length);
                  break;
                case '[object Boolean]':
                  clone = new ctor(value == true);
                  break;
                case '[object Date]':
                  clone = new ctor(+value);
                  break;
                case '[object Object]':
                  isPlainObject(value) && (clone = {});
                  break;
                case '[object Number]':
                case '[object String]':
                  clone = new ctor(value);
                  break;
                case '[object RegExp]':
                  clone = ctor(value.source, (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''));
              }
            }
            if (clone && clone != value && !(descriptor = source && support.descriptors && getDescriptor(source, key), accessor = descriptor && (descriptor.get || descriptor.set))) {
              if ((extensible = isExtensible(value))) {
                markerKey = getMarkerKey(value);
                if (value[markerKey]) {
                  circular = clone = value[markerKey].raw;
                }
              } else {
                for (subIndex = 0, length = unmarked.length; subIndex < length; subIndex++) {
                  data = unmarked[subIndex];
                  if (data.object === value) {
                    circular = clone = data.clone;
                    break;
                  }
                }
              }
              if (!circular) {
                if (extensible) {
                  value[markerKey] = new Marker(clone);
                  marked.push({
                    'key': markerKey,
                    'object': value
                  });
                } else {
                  unmarked.push({
                    'clone': clone,
                    'object': value
                  });
                }
                forProps(value, forPropsCallback, {'which': 'all'});
              }
            }
          }
          if (parent) {
            if (accessor || (descriptor && !(descriptor.configurable && descriptor.enumerable && descriptor.writable))) {
              if ('value' in descriptor) {
                descriptor.value = clone;
              }
              setDescriptor(parent, key, descriptor);
            } else {
              parent[key] = clone;
            }
          } else {
            result = clone;
          }
        } while ((data = queue[index++]));
        for (index = 0, length = marked.length; index < length; index++) {
          data = marked[index];
          delete data.object[data.key];
        }
        return result;
      }
      function each(object, callback, thisArg) {
        var result = object;
        object = Object(object);
        var fn = callback,
            index = -1,
            length = object.length,
            isSnapshot = !!(object.snapshotItem && (length = object.snapshotLength)),
            isSplittable = (noCharByIndex || noCharByOwnIndex) && isClassOf(object, 'String'),
            isConvertable = isSnapshot || isSplittable || 'item' in object,
            origObject = object;
        if (length === length >>> 0) {
          if (isConvertable) {
            callback = function(value, index) {
              return fn.call(this, value, index, origObject);
            };
            if (isSplittable) {
              object = object.split('');
            } else {
              object = [];
              while (++index < length) {
                object[index] = isSnapshot ? result.snapshotItem(index) : result[index];
              }
            }
          }
          forEach(object, callback, thisArg);
        } else {
          forOwn(object, callback, thisArg);
        }
        return result;
      }
      function extend(destination, source) {
        var result = destination;
        delete arguments[0];
        forEach(arguments, function(source) {
          forProps(source, function(value, key) {
            result[key] = value;
          });
        });
        return result;
      }
      function filter(array, callback, thisArg) {
        var result;
        if (callback == 'successful') {
          callback = function(bench) {
            return bench.cycles && isFinite(bench.hz);
          };
        } else if (callback == 'fastest' || callback == 'slowest') {
          result = filter(array, 'successful').sort(function(a, b) {
            a = a.stats;
            b = b.stats;
            return (a.mean + a.moe > b.mean + b.moe ? 1 : -1) * (callback == 'fastest' ? 1 : -1);
          });
          result = filter(result, function(bench) {
            return result[0].compare(bench) == 0;
          });
        }
        return result || reduce(array, function(result, value, index) {
          return callback.call(thisArg, value, index, array) ? (result.push(value), result) : result;
        }, []);
      }
      function forEach(array, callback, thisArg) {
        var index = -1,
            length = (array = Object(array)).length >>> 0;
        if (thisArg !== undefined) {
          callback = bind(callback, thisArg);
        }
        while (++index < length) {
          if (index in array && callback(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function forOwn(object, callback, thisArg) {
        return forProps(object, callback, {
          'bind': thisArg,
          'which': 'own'
        });
      }
      function formatNumber(number) {
        number = String(number).split('.');
        return number[0].replace(/(?=(?:\d{3})+$)(?!\b)/g, ',') + (number[1] ? '.' + number[1] : '');
      }
      function hasKey() {
        hasKey = function(object, key) {
          var parent = object != null && (object.constructor || Object).prototype;
          return !!parent && key in Object(object) && !(key in parent && object[key] === parent[key]);
        };
        if (isClassOf(hasOwnProperty, 'Function')) {
          hasKey = function(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          };
        } else if ({}.__proto__ == Object.prototype) {
          hasKey = function(object, key) {
            var result = false;
            if (object != null) {
              object = Object(object);
              object.__proto__ = [object.__proto__, object.__proto__ = null, result = key in object][0];
            }
            return result;
          };
        }
        return hasKey.apply(this, arguments);
      }
      function indexOf(array, value, fromIndex) {
        var index = toInteger(fromIndex),
            length = (array = Object(array)).length >>> 0;
        index = (index < 0 ? max(0, length + index) : index) - 1;
        while (++index < length) {
          if (index in array && value === array[index]) {
            return index;
          }
        }
        return -1;
      }
      function interpolate(string, object) {
        forOwn(object, function(value, key) {
          string = string.replace(RegExp('#\\{' + key.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1') + '\\}', 'g'), value);
        });
        return string;
      }
      function invoke(benches, name) {
        var args,
            bench,
            queued,
            index = -1,
            eventProps = {'currentTarget': benches},
            options = {
              'onStart': noop,
              'onCycle': noop,
              'onComplete': noop
            },
            result = map(benches, function(bench) {
              return bench;
            });
        function execute() {
          var listeners,
              async = isAsync(bench);
          if (async) {
            bench.on('complete', getNext);
            listeners = bench.events.complete;
            listeners.splice(0, 0, listeners.pop());
          }
          result[index] = isClassOf(bench && bench[name], 'Function') ? bench[name].apply(bench, args) : undefined;
          return !async && getNext();
        }
        function getNext(event) {
          var cycleEvent,
              last = bench,
              async = isAsync(last);
          if (async) {
            last.off('complete', getNext);
            last.emit('complete');
          }
          eventProps.type = 'cycle';
          eventProps.target = last;
          cycleEvent = Event(eventProps);
          options.onCycle.call(benches, cycleEvent);
          if (!cycleEvent.aborted && raiseIndex() !== false) {
            bench = queued ? benches[0] : result[index];
            if (isAsync(bench)) {
              delay(bench, execute);
            } else if (async) {
              while (execute()) {}
            } else {
              return true;
            }
          } else {
            eventProps.type = 'complete';
            options.onComplete.call(benches, Event(eventProps));
          }
          if (event) {
            event.aborted = true;
          } else {
            return false;
          }
        }
        function isAsync(object) {
          var async = args[0] && args[0].async;
          return Object(object).constructor == Benchmark && name == 'run' && ((async == null ? object.options.async : async) && support.timeout || object.defer);
        }
        function raiseIndex() {
          var length = result.length;
          if (queued) {
            do {
              ++index > 0 && shift.call(benches);
            } while ((length = benches.length) && !('0' in benches));
          } else {
            while (++index < length && !(index in result)) {}
          }
          return (queued ? length : index < length) ? index : (index = false);
        }
        if (isClassOf(name, 'String')) {
          args = slice.call(arguments, 2);
        } else {
          options = extend(options, name);
          name = options.name;
          args = isClassOf(args = 'args' in options ? options.args : [], 'Array') ? args : [args];
          queued = options.queued;
        }
        if (raiseIndex() !== false) {
          bench = result[index];
          eventProps.type = 'start';
          eventProps.target = bench;
          options.onStart.call(benches, Event(eventProps));
          if (benches.aborted && benches.constructor == Suite && name == 'run') {
            eventProps.type = 'cycle';
            options.onCycle.call(benches, Event(eventProps));
            eventProps.type = 'complete';
            options.onComplete.call(benches, Event(eventProps));
          } else {
            if (isAsync(bench)) {
              delay(bench, execute);
            } else {
              while (execute()) {}
            }
          }
        }
        return result;
      }
      function join(object, separator1, separator2) {
        var result = [],
            length = (object = Object(object)).length,
            arrayLike = length === length >>> 0;
        separator2 || (separator2 = ': ');
        each(object, function(value, key) {
          result.push(arrayLike ? value : key + separator2 + value);
        });
        return result.join(separator1 || ',');
      }
      function map(array, callback, thisArg) {
        return reduce(array, function(result, value, index) {
          result[index] = callback.call(thisArg, value, index, array);
          return result;
        }, Array(Object(array).length >>> 0));
      }
      function pluck(array, property) {
        return map(array, function(object) {
          return object == null ? undefined : object[property];
        });
      }
      function reduce(array, callback, accumulator) {
        var noaccum = arguments.length < 3;
        forEach(array, function(value, index) {
          accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, array);
        });
        return accumulator;
      }
      function abortSuite() {
        var event,
            me = this,
            resetting = calledBy.resetSuite;
        if (me.running) {
          event = Event('abort');
          me.emit(event);
          if (!event.cancelled || resetting) {
            calledBy.abortSuite = true;
            me.reset();
            delete calledBy.abortSuite;
            if (!resetting) {
              me.aborted = true;
              invoke(me, 'abort');
            }
          }
        }
        return me;
      }
      function add(name, fn, options) {
        var me = this,
            bench = Benchmark(name, fn, options),
            event = Event({
              'type': 'add',
              'target': bench
            });
        if (me.emit(event), !event.cancelled) {
          me.push(bench);
        }
        return me;
      }
      function cloneSuite(options) {
        var me = this,
            result = new me.constructor(extend({}, me.options, options));
        forOwn(me, function(value, key) {
          if (!hasKey(result, key)) {
            result[key] = value && isClassOf(value.clone, 'Function') ? value.clone() : deepClone(value);
          }
        });
        return result;
      }
      function filterSuite(callback) {
        var me = this,
            result = new me.constructor;
        result.push.apply(result, filter(me, callback));
        return result;
      }
      function resetSuite() {
        var event,
            me = this,
            aborting = calledBy.abortSuite;
        if (me.running && !aborting) {
          calledBy.resetSuite = true;
          me.abort();
          delete calledBy.resetSuite;
        } else if ((me.aborted || me.running) && (me.emit(event = Event('reset')), !event.cancelled)) {
          me.running = false;
          if (!aborting) {
            invoke(me, 'reset');
          }
        }
        return me;
      }
      function runSuite(options) {
        var me = this;
        me.reset();
        me.running = true;
        options || (options = {});
        invoke(me, {
          'name': 'run',
          'args': options,
          'queued': options.queued,
          'onStart': function(event) {
            me.emit(event);
          },
          'onCycle': function(event) {
            var bench = event.target;
            if (bench.error) {
              me.emit({
                'type': 'error',
                'target': bench
              });
            }
            me.emit(event);
            event.aborted = me.aborted;
          },
          'onComplete': function(event) {
            me.running = false;
            me.emit(event);
          }
        });
        return me;
      }
      function emit(type) {
        var listeners,
            me = this,
            event = Event(type),
            events = me.events,
            args = (arguments[0] = event, arguments);
        event.currentTarget || (event.currentTarget = me);
        event.target || (event.target = me);
        delete event.result;
        if (events && (listeners = hasKey(events, event.type) && events[event.type])) {
          forEach(listeners.slice(), function(listener) {
            if ((event.result = listener.apply(me, args)) === false) {
              event.cancelled = true;
            }
            return !event.aborted;
          });
        }
        return event.result;
      }
      function listeners(type) {
        var me = this,
            events = me.events || (me.events = {});
        return hasKey(events, type) ? events[type] : (events[type] = []);
      }
      function off(type, listener) {
        var me = this,
            events = me.events;
        events && each(type ? type.split(' ') : events, function(listeners, type) {
          var index;
          if (typeof listeners == 'string') {
            type = listeners;
            listeners = hasKey(events, type) && events[type];
          }
          if (listeners) {
            if (listener) {
              index = indexOf(listeners, listener);
              if (index > -1) {
                listeners.splice(index, 1);
              }
            } else {
              listeners.length = 0;
            }
          }
        });
        return me;
      }
      function on(type, listener) {
        var me = this,
            events = me.events || (me.events = {});
        forEach(type.split(' '), function(type) {
          (hasKey(events, type) ? events[type] : (events[type] = [])).push(listener);
        });
        return me;
      }
      function abort() {
        var event,
            me = this,
            resetting = calledBy.reset;
        if (me.running) {
          event = Event('abort');
          me.emit(event);
          if (!event.cancelled || resetting) {
            calledBy.abort = true;
            me.reset();
            delete calledBy.abort;
            if (support.timeout) {
              clearTimeout(me._timerId);
              delete me._timerId;
            }
            if (!resetting) {
              me.aborted = true;
              me.running = false;
            }
          }
        }
        return me;
      }
      function clone(options) {
        var me = this,
            result = new me.constructor(extend({}, me, options));
        result.options = extend({}, me.options, options);
        forOwn(me, function(value, key) {
          if (!hasKey(result, key)) {
            result[key] = deepClone(value);
          }
        });
        return result;
      }
      function compare(other) {
        var critical,
            zStat,
            me = this,
            sample1 = me.stats.sample,
            sample2 = other.stats.sample,
            size1 = sample1.length,
            size2 = sample2.length,
            maxSize = max(size1, size2),
            minSize = min(size1, size2),
            u1 = getU(sample1, sample2),
            u2 = getU(sample2, sample1),
            u = min(u1, u2);
        function getScore(xA, sampleB) {
          return reduce(sampleB, function(total, xB) {
            return total + (xB > xA ? 0 : xB < xA ? 1 : 0.5);
          }, 0);
        }
        function getU(sampleA, sampleB) {
          return reduce(sampleA, function(total, xA) {
            return total + getScore(xA, sampleB);
          }, 0);
        }
        function getZ(u) {
          return (u - ((size1 * size2) / 2)) / sqrt((size1 * size2 * (size1 + size2 + 1)) / 12);
        }
        if (me == other) {
          return 0;
        }
        if (size1 + size2 > 30) {
          zStat = getZ(u);
          return abs(zStat) > 1.96 ? (zStat > 0 ? -1 : 1) : 0;
        }
        critical = maxSize < 5 || minSize < 3 ? 0 : uTable[maxSize][minSize - 3];
        return u <= critical ? (u == u1 ? 1 : -1) : 0;
      }
      function reset() {
        var data,
            event,
            me = this,
            index = 0,
            changes = {'length': 0},
            queue = {'length': 0};
        if (me.running && !calledBy.abort) {
          calledBy.reset = true;
          me.abort();
          delete calledBy.reset;
        } else {
          data = {
            'destination': me,
            'source': extend({}, me.constructor.prototype, me.options)
          };
          do {
            forOwn(data.source, function(value, key) {
              var changed,
                  destination = data.destination,
                  currValue = destination[key];
              if (value && typeof value == 'object') {
                if (isClassOf(value, 'Array')) {
                  if (!isClassOf(currValue, 'Array')) {
                    changed = currValue = [];
                  }
                  if (currValue.length != value.length) {
                    changed = currValue = currValue.slice(0, value.length);
                    currValue.length = value.length;
                  }
                } else if (!currValue || typeof currValue != 'object') {
                  changed = currValue = {};
                }
                if (changed) {
                  changes[changes.length++] = {
                    'destination': destination,
                    'key': key,
                    'value': currValue
                  };
                }
                queue[queue.length++] = {
                  'destination': currValue,
                  'source': value
                };
              } else if (value !== currValue && !(value == null || isClassOf(value, 'Function'))) {
                changes[changes.length++] = {
                  'destination': destination,
                  'key': key,
                  'value': value
                };
              }
            });
          } while ((data = queue[index++]));
          if (changes.length && (me.emit(event = Event('reset')), !event.cancelled)) {
            forEach(changes, function(data) {
              data.destination[data.key] = data.value;
            });
          }
        }
        return me;
      }
      function toStringBench() {
        var me = this,
            error = me.error,
            hz = me.hz,
            id = me.id,
            stats = me.stats,
            size = stats.sample.length,
            pm = support.java ? '+/-' : '\xb1',
            result = me.name || (isNaN(id) ? id : '<Test #' + id + '>');
        if (error) {
          result += ': ' + join(error);
        } else {
          result += ' x ' + formatNumber(hz.toFixed(hz < 100 ? 2 : 0)) + ' ops/sec ' + pm + stats.rme.toFixed(2) + '% (' + size + ' run' + (size == 1 ? '' : 's') + ' sampled)';
        }
        return result;
      }
      function clock() {
        var applet,
            options = Benchmark.options,
            template = {
              'begin': 's$=new n$',
              'end': 'r$=(new n$-s$)/1e3',
              'uid': uid
            },
            timers = [{
              'ns': timer.ns,
              'res': max(0.0015, getRes('ms')),
              'unit': 'ms'
            }];
        clock = function(clone) {
          var deferred;
          if (clone instanceof Deferred) {
            deferred = clone;
            clone = deferred.benchmark;
          }
          var bench = clone._original,
              fn = bench.fn,
              fnArg = deferred ? getFirstArgument(fn) || 'deferred' : '',
              stringable = isStringable(fn);
          var source = {
            'setup': getSource(bench.setup, preprocess('m$.setup()')),
            'fn': getSource(fn, preprocess('m$.fn(' + fnArg + ')')),
            'fnArg': fnArg,
            'teardown': getSource(bench.teardown, preprocess('m$.teardown()'))
          };
          var count = bench.count = clone.count,
              decompilable = support.decompilation || stringable,
              id = bench.id,
              isEmpty = !(source.fn || stringable),
              name = bench.name || (typeof id == 'number' ? '<Test #' + id + '>' : id),
              ns = timer.ns,
              result = 0;
          clone.minTime = bench.minTime || (bench.minTime = bench.options.minTime = options.minTime);
          if (applet) {
            try {
              ns.nanoTime();
            } catch (e) {
              ns = timer.ns = new applet.Packages.nano;
            }
          }
          var compiled = bench.compiled = createFunction(preprocess('t$'), interpolate(preprocess(deferred ? 'var d$=this,#{fnArg}=d$,m$=d$.benchmark._original,f$=m$.fn,su$=m$.setup,td$=m$.teardown;' + 'if(!d$.cycles){' + 'd$.fn=function(){var #{fnArg}=d$;if(typeof f$=="function"){try{#{fn}\n}catch(e$){f$(d$)}}else{#{fn}\n}};' + 'd$.teardown=function(){d$.cycles=0;if(typeof td$=="function"){try{#{teardown}\n}catch(e$){td$()}}else{#{teardown}\n}};' + 'if(typeof su$=="function"){try{#{setup}\n}catch(e$){su$()}}else{#{setup}\n};' + 't$.start(d$);' + '}d$.fn();return{}' : 'var r$,s$,m$=this,f$=m$.fn,i$=m$.count,n$=t$.ns;#{setup}\n#{begin};' + 'while(i$--){#{fn}\n}#{end};#{teardown}\nreturn{elapsed:r$,uid:"#{uid}"}'), source));
          try {
            if (isEmpty) {
              throw new Error('The test "' + name + '" is empty. This may be the result of dead code removal.');
            } else if (!deferred) {
              bench.count = 1;
              compiled = (compiled.call(bench, timer) || {}).uid == uid && compiled;
              bench.count = count;
            }
          } catch (e) {
            compiled = null;
            clone.error = e || new Error(String(e));
            bench.count = count;
          }
          if (decompilable && !compiled && !deferred && !isEmpty) {
            compiled = createFunction(preprocess('t$'), interpolate(preprocess((clone.error && !stringable ? 'var r$,s$,m$=this,f$=m$.fn,i$=m$.count' : 'function f$(){#{fn}\n}var r$,s$,m$=this,i$=m$.count') + ',n$=t$.ns;#{setup}\n#{begin};m$.f$=f$;while(i$--){m$.f$()}#{end};' + 'delete m$.f$;#{teardown}\nreturn{elapsed:r$}'), source));
            try {
              bench.count = 1;
              compiled.call(bench, timer);
              bench.compiled = compiled;
              bench.count = count;
              delete clone.error;
            } catch (e) {
              bench.count = count;
              if (clone.error) {
                compiled = null;
              } else {
                bench.compiled = compiled;
                clone.error = e || new Error(String(e));
              }
            }
          }
          clone.compiled = compiled;
          if (!clone.error) {
            result = compiled.call(deferred || bench, timer).elapsed;
          }
          return result;
        };
        function getRes(unit) {
          var measured,
              begin,
              count = 30,
              divisor = 1e3,
              ns = timer.ns,
              sample = [];
          while (count--) {
            if (unit == 'us') {
              divisor = 1e6;
              if (ns.stop) {
                ns.start();
                while (!(measured = ns.microseconds())) {}
              } else if (ns[perfName]) {
                divisor = 1e3;
                measured = Function('n', 'var r,s=n.' + perfName + '();while(!(r=n.' + perfName + '()-s)){};return r')(ns);
              } else {
                begin = ns();
                while (!(measured = ns() - begin)) {}
              }
            } else if (unit == 'ns') {
              divisor = 1e9;
              if (ns.nanoTime) {
                begin = ns.nanoTime();
                while (!(measured = ns.nanoTime() - begin)) {}
              } else {
                begin = (begin = ns())[0] + (begin[1] / divisor);
                while (!(measured = ((measured = ns())[0] + (measured[1] / divisor)) - begin)) {}
                divisor = 1;
              }
            } else {
              begin = new ns;
              while (!(measured = new ns - begin)) {}
            }
            if (measured > 0) {
              sample.push(measured);
            } else {
              sample.push(Infinity);
              break;
            }
          }
          return getMean(sample) / divisor;
        }
        function preprocess(code) {
          return interpolate(code, template).replace(/\$/g, /\d+/.exec(uid));
        }
        each(doc && doc.applets || [], function(element) {
          return !(timer.ns = applet = 'nanoTime' in element && element);
        });
        try {
          if (typeof timer.ns.nanoTime() == 'number') {
            timers.push({
              'ns': timer.ns,
              'res': getRes('ns'),
              'unit': 'ns'
            });
          }
        } catch (e) {}
        try {
          if ((timer.ns = new (window.chrome || window.chromium).Interval)) {
            timers.push({
              'ns': timer.ns,
              'res': getRes('us'),
              'unit': 'us'
            });
          }
        } catch (e) {}
        if ((timer.ns = perfName && perfObject)) {
          timers.push({
            'ns': timer.ns,
            'res': getRes('us'),
            'unit': 'us'
          });
        }
        if (processObject && typeof(timer.ns = processObject.hrtime) == 'function') {
          timers.push({
            'ns': timer.ns,
            'res': getRes('ns'),
            'unit': 'ns'
          });
        }
        if (microtimeObject && typeof(timer.ns = microtimeObject.now) == 'function') {
          timers.push({
            'ns': timer.ns,
            'res': getRes('us'),
            'unit': 'us'
          });
        }
        timer = reduce(timers, function(timer, other) {
          return other.res < timer.res ? other : timer;
        });
        if (timer.unit != 'ns' && applet) {
          applet = destroyElement(applet);
        }
        if (timer.res == Infinity) {
          throw new Error('Benchmark.js was unable to find a working timer.');
        }
        if (timer.unit == 'ns') {
          if (timer.ns.nanoTime) {
            extend(template, {
              'begin': 's$=n$.nanoTime()',
              'end': 'r$=(n$.nanoTime()-s$)/1e9'
            });
          } else {
            extend(template, {
              'begin': 's$=n$()',
              'end': 'r$=n$(s$);r$=r$[0]+(r$[1]/1e9)'
            });
          }
        } else if (timer.unit == 'us') {
          if (timer.ns.stop) {
            extend(template, {
              'begin': 's$=n$.start()',
              'end': 'r$=n$.microseconds()/1e6'
            });
          } else if (perfName) {
            extend(template, {
              'begin': 's$=n$.' + perfName + '()',
              'end': 'r$=(n$.' + perfName + '()-s$)/1e3'
            });
          } else {
            extend(template, {
              'begin': 's$=n$()',
              'end': 'r$=(n$()-s$)/1e6'
            });
          }
        }
        timer.start = createFunction(preprocess('o$'), preprocess('var n$=this.ns,#{begin};o$.elapsed=0;o$.timeStamp=s$'));
        timer.stop = createFunction(preprocess('o$'), preprocess('var n$=this.ns,s$=o$.timeStamp,#{end};o$.elapsed=r$'));
        options.minTime || (options.minTime = max(timer.res / 2 / 0.01, 0.05));
        return clock.apply(null, arguments);
      }
      function compute(bench, options) {
        options || (options = {});
        var async = options.async,
            elapsed = 0,
            initCount = bench.initCount,
            minSamples = bench.minSamples,
            queue = [],
            sample = bench.stats.sample;
        function enqueue() {
          queue.push(bench.clone({
            '_original': bench,
            'events': {
              'abort': [update],
              'cycle': [update],
              'error': [update],
              'start': [update]
            }
          }));
        }
        function update(event) {
          var clone = this,
              type = event.type;
          if (bench.running) {
            if (type == 'start') {
              clone.count = bench.initCount;
            } else {
              if (type == 'error') {
                bench.error = clone.error;
              }
              if (type == 'abort') {
                bench.abort();
                bench.emit('cycle');
              } else {
                event.currentTarget = event.target = bench;
                bench.emit(event);
              }
            }
          } else if (bench.aborted) {
            clone.events.abort.length = 0;
            clone.abort();
          }
        }
        function evaluate(event) {
          var critical,
              df,
              mean,
              moe,
              rme,
              sd,
              sem,
              variance,
              clone = event.target,
              done = bench.aborted,
              now = +new Date,
              size = sample.push(clone.times.period),
              maxedOut = size >= minSamples && (elapsed += now - clone.times.timeStamp) / 1e3 > bench.maxTime,
              times = bench.times,
              varOf = function(sum, x) {
                return sum + pow(x - mean, 2);
              };
          if (done || clone.hz == Infinity) {
            maxedOut = !(size = sample.length = queue.length = 0);
          }
          if (!done) {
            mean = getMean(sample);
            variance = reduce(sample, varOf, 0) / (size - 1) || 0;
            sd = sqrt(variance);
            sem = sd / sqrt(size);
            df = size - 1;
            critical = tTable[Math.round(df) || 1] || tTable.infinity;
            moe = sem * critical;
            rme = (moe / mean) * 100 || 0;
            extend(bench.stats, {
              'deviation': sd,
              'mean': mean,
              'moe': moe,
              'rme': rme,
              'sem': sem,
              'variance': variance
            });
            if (maxedOut) {
              bench.initCount = initCount;
              bench.running = false;
              done = true;
              times.elapsed = (now - times.timeStamp) / 1e3;
            }
            if (bench.hz != Infinity) {
              bench.hz = 1 / mean;
              times.cycle = mean * bench.count;
              times.period = mean;
            }
          }
          if (queue.length < 2 && !maxedOut) {
            enqueue();
          }
          event.aborted = done;
        }
        enqueue();
        invoke(queue, {
          'name': 'run',
          'args': {'async': async},
          'queued': true,
          'onCycle': evaluate,
          'onComplete': function() {
            bench.emit('complete');
          }
        });
      }
      function cycle(clone, options) {
        options || (options = {});
        var deferred;
        if (clone instanceof Deferred) {
          deferred = clone;
          clone = clone.benchmark;
        }
        var clocked,
            cycles,
            divisor,
            event,
            minTime,
            period,
            async = options.async,
            bench = clone._original,
            count = clone.count,
            times = clone.times;
        if (clone.running) {
          cycles = ++clone.cycles;
          clocked = deferred ? deferred.elapsed : clock(clone);
          minTime = clone.minTime;
          if (cycles > bench.cycles) {
            bench.cycles = cycles;
          }
          if (clone.error) {
            event = Event('error');
            event.message = clone.error;
            clone.emit(event);
            if (!event.cancelled) {
              clone.abort();
            }
          }
        }
        if (clone.running) {
          bench.times.cycle = times.cycle = clocked;
          period = bench.times.period = times.period = clocked / count;
          bench.hz = clone.hz = 1 / period;
          bench.initCount = clone.initCount = count;
          clone.running = clocked < minTime;
          if (clone.running) {
            if (!clocked && (divisor = divisors[clone.cycles]) != null) {
              count = floor(4e6 / divisor);
            }
            if (count <= clone.count) {
              count += Math.ceil((minTime - clocked) / period);
            }
            clone.running = count != Infinity;
          }
        }
        event = Event('cycle');
        clone.emit(event);
        if (event.aborted) {
          clone.abort();
        }
        if (clone.running) {
          clone.count = count;
          if (deferred) {
            clone.compiled.call(deferred, timer);
          } else if (async) {
            delay(clone, function() {
              cycle(clone, options);
            });
          } else {
            cycle(clone);
          }
        } else {
          if (support.browser) {
            runScript(uid + '=1;delete ' + uid);
          }
          clone.emit('complete');
        }
      }
      function run(options) {
        var me = this,
            event = Event('start');
        me.running = false;
        me.reset();
        me.running = true;
        me.count = me.initCount;
        me.times.timeStamp = +new Date;
        me.emit(event);
        if (!event.cancelled) {
          options = {'async': ((options = options && options.async) == null ? me.async : options) && support.timeout};
          if (me._original) {
            if (me.defer) {
              Deferred(me);
            } else {
              cycle(me, options);
            }
          } else {
            compute(me, options);
          }
        }
        return me;
      }
      extend(Benchmark, {
        'options': {
          'async': false,
          'defer': false,
          'delay': 0.005,
          'id': undefined,
          'initCount': 1,
          'maxTime': 5,
          'minSamples': 5,
          'minTime': 0,
          'name': undefined,
          'onAbort': undefined,
          'onComplete': undefined,
          'onCycle': undefined,
          'onError': undefined,
          'onReset': undefined,
          'onStart': undefined
        },
        'platform': req('platform') || window.platform || {
          'description': window.navigator && navigator.userAgent || null,
          'layout': null,
          'product': null,
          'name': null,
          'manufacturer': null,
          'os': null,
          'prerelease': null,
          'version': null,
          'toString': function() {
            return this.description || '';
          }
        },
        'version': '1.0.0',
        'support': support,
        'deepClone': deepClone,
        'each': each,
        'extend': extend,
        'filter': filter,
        'forEach': forEach,
        'forOwn': forOwn,
        'formatNumber': formatNumber,
        'hasKey': (hasKey(Benchmark, ''), hasKey),
        'indexOf': indexOf,
        'interpolate': interpolate,
        'invoke': invoke,
        'join': join,
        'map': map,
        'pluck': pluck,
        'reduce': reduce
      });
      extend(Benchmark.prototype, {
        'count': 0,
        'cycles': 0,
        'hz': 0,
        'compiled': undefined,
        'error': undefined,
        'fn': undefined,
        'aborted': false,
        'running': false,
        'setup': noop,
        'teardown': noop,
        'stats': {
          'moe': 0,
          'rme': 0,
          'sem': 0,
          'deviation': 0,
          'mean': 0,
          'sample': [],
          'variance': 0
        },
        'times': {
          'cycle': 0,
          'elapsed': 0,
          'period': 0,
          'timeStamp': 0
        },
        'abort': abort,
        'clone': clone,
        'compare': compare,
        'emit': emit,
        'listeners': listeners,
        'off': off,
        'on': on,
        'reset': reset,
        'run': run,
        'toString': toStringBench
      });
      extend(Deferred.prototype, {
        'benchmark': null,
        'cycles': 0,
        'elapsed': 0,
        'timeStamp': 0,
        'resolve': resolve
      });
      extend(Event.prototype, {
        'aborted': false,
        'cancelled': false,
        'currentTarget': undefined,
        'result': undefined,
        'target': undefined,
        'timeStamp': 0,
        'type': ''
      });
      Suite.options = {'name': undefined};
      extend(Suite.prototype, {
        'length': 0,
        'aborted': false,
        'running': false,
        'forEach': methodize(forEach),
        'indexOf': methodize(indexOf),
        'invoke': methodize(invoke),
        'join': [].join,
        'map': methodize(map),
        'pluck': methodize(pluck),
        'pop': [].pop,
        'push': [].push,
        'sort': [].sort,
        'reduce': methodize(reduce),
        'abort': abortSuite,
        'add': add,
        'clone': cloneSuite,
        'emit': emit,
        'filter': filterSuite,
        'listeners': listeners,
        'off': off,
        'on': on,
        'reset': resetSuite,
        'run': runSuite,
        'concat': concat,
        'reverse': reverse,
        'shift': shift,
        'slice': slice,
        'splice': splice,
        'unshift': unshift
      });
      extend(Benchmark, {
        'Deferred': Deferred,
        'Event': Event,
        'Suite': Suite
      });
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define(function() {
          return Benchmark;
        });
      } else if (freeExports) {
        if (typeof module == 'object' && module && module.exports == freeExports) {
          (module.exports = Benchmark).Benchmark = Benchmark;
        } else {
          freeExports.Benchmark = Benchmark;
        }
      } else {
        window['Benchmark'] = Benchmark;
      }
      if (support.air) {
        clock({'_original': {
            'fn': noop,
            'count': 1,
            'options': {}
          }});
      }
    }(this));
  })(req('5'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7", ["6"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function() {
    'use strict';
    var objectTypes = {
      'function': true,
      'object': true
    };
    var root = (objectTypes[typeof window] && window) || this;
    var oldRoot = root;
    var freeExports = objectTypes[typeof exports] && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
      root = freeGlobal;
    }
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var reOpera = /\bOpera/;
    var thisBinding = this;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var toString = objectProto.toString;
    function capitalize(string) {
      string = String(string);
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function cleanupOS(os, pattern, label) {
      var data = {
        '6.4': '10',
        '6.3': '8.1',
        '6.2': '8',
        '6.1': 'Server 2008 R2 / 7',
        '6.0': 'Server 2008 / Vista',
        '5.2': 'Server 2003 / XP 64-bit',
        '5.1': 'XP',
        '5.01': '2000 SP1',
        '5.0': '2000',
        '4.0': 'NT',
        '4.90': 'ME'
      };
      if (pattern && label && /^Win/i.test(os) && (data = data[0, /[\d.]+$/.exec(os)])) {
        os = 'Windows ' + data;
      }
      os = String(os);
      if (pattern && label) {
        os = os.replace(RegExp(pattern, 'i'), label);
      }
      os = format(os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_PowerPC\b/i, ' OS').replace(/\b(OS X) [^ \d]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').split(' on ')[0]);
      return os;
    }
    function each(object, callback) {
      var index = -1,
          length = object ? object.length : 0;
      if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
        while (++index < length) {
          callback(object[index], index, object);
        }
      } else {
        forOwn(object, callback);
      }
    }
    function format(string) {
      string = trim(string);
      return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
    }
    function forOwn(object, callback) {
      for (var key in object) {
        if (hasOwnProperty.call(object, key)) {
          callback(object[key], key, object);
        }
      }
    }
    function getClassOf(value) {
      return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
    }
    function isHostType(object, property) {
      var type = object != null ? typeof object[property] : 'number';
      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == 'object' ? !!object[property] : true);
    }
    function qualify(string) {
      return String(string).replace(/([ -])(?!$)/g, '$1?');
    }
    function reduce(array, callback) {
      var accumulator = null;
      each(array, function(value, index) {
        accumulator = callback(accumulator, value, index, array);
      });
      return accumulator;
    }
    function trim(string) {
      return String(string).replace(/^ +| +$/g, '');
    }
    function parse(ua) {
      var context = root;
      var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';
      if (isCustomContext) {
        context = ua;
        ua = null;
      }
      var nav = context.navigator || {};
      var userAgent = nav.userAgent || '';
      ua || (ua = userAgent);
      var isModuleScope = isCustomContext || thisBinding == oldRoot;
      var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
      var objectClass = 'Object',
          airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
          enviroClass = isCustomContext ? objectClass : 'Environment',
          javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
          phantomClass = isCustomContext ? objectClass : 'RuntimeObject';
      var java = /\bJava/.test(javaClass) && context.java;
      var rhino = java && getClassOf(context.environment) == enviroClass;
      var alpha = java ? 'a' : '\u03b1';
      var beta = java ? 'b' : '\u03b2';
      var doc = context.document || {};
      var opera = context.operamini || context.opera;
      var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera)) ? operaClass : (opera = null);
      var data;
      var arch = ua;
      var description = [];
      var prerelease = null;
      var useFeatures = ua == userAgent;
      var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();
      var isSpecialCasedOS;
      var layout = getLayout(['Trident', {
        'label': 'WebKit',
        'pattern': 'AppleWebKit'
      }, 'iCab', 'Presto', 'NetFront', 'Tasman', 'KHTML', 'Gecko']);
      var name = getName(['Adobe AIR', 'Arora', 'Avant Browser', 'Breach', 'Camino', 'Epiphany', 'Fennec', 'Flock', 'Galeon', 'GreenBrowser', 'iCab', 'Iceweasel', {
        'label': 'SRWare Iron',
        'pattern': 'Iron'
      }, 'K-Meleon', 'Konqueror', 'Lunascape', 'Maxthon', 'Midori', 'Nook Browser', 'PhantomJS', 'Raven', 'Rekonq', 'RockMelt', 'SeaMonkey', {
        'label': 'Silk',
        'pattern': '(?:Cloud9|Silk-Accelerated)'
      }, 'Sleipnir', 'SlimBrowser', 'Sunrise', 'Swiftfox', 'WebPositive', 'Opera Mini', {
        'label': 'Opera Mini',
        'pattern': 'OPiOS'
      }, 'Opera', {
        'label': 'Opera',
        'pattern': 'OPR'
      }, 'Chrome', {
        'label': 'Chrome Mobile',
        'pattern': '(?:CriOS|CrMo)'
      }, {
        'label': 'Firefox',
        'pattern': '(?:Firefox|Minefield)'
      }, {
        'label': 'IE',
        'pattern': 'IEMobile'
      }, {
        'label': 'IE',
        'pattern': 'MSIE'
      }, 'Safari']);
      var product = getProduct([{
        'label': 'BlackBerry',
        'pattern': 'BB10'
      }, 'BlackBerry', {
        'label': 'Galaxy S',
        'pattern': 'GT-I9000'
      }, {
        'label': 'Galaxy S2',
        'pattern': 'GT-I9100'
      }, {
        'label': 'Galaxy S3',
        'pattern': 'GT-I9300'
      }, {
        'label': 'Galaxy S4',
        'pattern': 'GT-I9500'
      }, 'Google TV', 'Lumia', 'iPad', 'iPod', 'iPhone', 'Kindle', {
        'label': 'Kindle Fire',
        'pattern': '(?:Cloud9|Silk-Accelerated)'
      }, 'Nook', 'PlayBook', 'PlayStation 4', 'PlayStation 3', 'PlayStation Vita', 'TouchPad', 'Transformer', {
        'label': 'Wii U',
        'pattern': 'WiiU'
      }, 'Wii', 'Xbox One', {
        'label': 'Xbox 360',
        'pattern': 'Xbox'
      }, 'Xoom']);
      var manufacturer = getManufacturer({
        'Apple': {
          'iPad': 1,
          'iPhone': 1,
          'iPod': 1
        },
        'Amazon': {
          'Kindle': 1,
          'Kindle Fire': 1
        },
        'Asus': {'Transformer': 1},
        'Barnes & Noble': {'Nook': 1},
        'BlackBerry': {'PlayBook': 1},
        'Google': {'Google TV': 1},
        'HP': {'TouchPad': 1},
        'HTC': {},
        'LG': {},
        'Microsoft': {
          'Xbox': 1,
          'Xbox One': 1
        },
        'Motorola': {'Xoom': 1},
        'Nintendo': {
          'Wii U': 1,
          'Wii': 1
        },
        'Nokia': {'Lumia': 1},
        'Samsung': {
          'Galaxy S': 1,
          'Galaxy S2': 1,
          'Galaxy S3': 1,
          'Galaxy S4': 1
        },
        'Sony': {
          'PlayStation 4': 1,
          'PlayStation 3': 1,
          'PlayStation Vita': 1
        }
      });
      var os = getOS(['Windows Phone ', 'Android', 'CentOS', 'Debian', 'Fedora', 'FreeBSD', 'Gentoo', 'Haiku', 'Kubuntu', 'Linux Mint', 'Red Hat', 'SuSE', 'Ubuntu', 'Xubuntu', 'Cygwin', 'Symbian OS', 'hpwOS', 'webOS ', 'webOS', 'Tablet OS', 'Linux', 'Mac OS X', 'Macintosh', 'Mac', 'Windows 98;', 'Windows ']);
      function getLayout(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
        });
      }
      function getManufacturer(guesses) {
        return reduce(guesses, function(result, value, key) {
          return result || (value[product] || value[0, /^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)) && key;
        });
      }
      function getName(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
        });
      }
      function getOS(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua))) {
            result = cleanupOS(result, pattern, guess.label || guess);
          }
          return result;
        });
      }
      function getProduct(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) || RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua))) {
            if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
              result[0] += ' ' + result[1];
            }
            guess = guess.label || guess;
            result = format(result[0].replace(RegExp(pattern, 'i'), guess).replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ').replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
          }
          return result;
        });
      }
      function getVersion(patterns) {
        return reduce(patterns, function(result, pattern) {
          return result || (RegExp(pattern + '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
        });
      }
      function toStringPlatform() {
        return this.description || '';
      }
      layout && (layout = [layout]);
      if (manufacturer && !product) {
        product = getProduct([manufacturer]);
      }
      if ((data = /\bGoogle TV\b/.exec(product))) {
        product = data[0];
      }
      if (/\bSimulator\b/i.test(ua)) {
        product = (product ? product + ' ' : '') + 'Simulator';
      }
      if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
        description.push('running in Turbo/Uncompressed mode');
      }
      if (/^iP/.test(product)) {
        name || (name = 'Safari');
        os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua)) ? ' ' + data[1].replace(/_/g, '.') : '');
      } else if (name == 'Konqueror' && !/buntu/i.test(os)) {
        os = 'Kubuntu';
      } else if (manufacturer && manufacturer != 'Google' && ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) {
        name = 'Android Browser';
        os = /\bAndroid\b/.test(os) ? os : 'Android';
      } else if (!name || (data = !/\bMinefield\b|\(Android;/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
        if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
          name = null;
        }
        if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
          name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
        }
      }
      if ((data = /\((Mobile|Tablet).*?Firefox\b/i.exec(ua)) && data[1]) {
        os = 'Firefox OS';
        if (!product) {
          product = data[1];
        }
      }
      if (!version) {
        version = getVersion(['(?:Cloud9|CriOS|CrMo|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))', 'Version', qualify(name), '(?:Firefox|Minefield|NetFront)']);
      }
      if (layout == 'iCab' && parseFloat(version) > 3) {
        layout = ['WebKit'];
      } else if (layout != 'Trident' && (data = /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && 'WebKit' || !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident'))) {
        layout = [data];
      } else if (/\bPlayStation\b(?! Vita\b)/i.test(name) && layout == 'WebKit') {
        layout = ['NetFront'];
      }
      if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
        name += ' Mobile';
        os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
        description.unshift('desktop mode');
      } else if (/\bWPDesktop\b/i.test(ua)) {
        name = 'IE Mobile';
        os = 'Windows Phone 8+';
        description.unshift('desktop mode');
        version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
      } else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
        if (!/\bWPDesktop\b/i.test(ua)) {
          if (name) {
            description.push('identifying as ' + name + (version ? ' ' + version : ''));
          }
          name = 'IE';
        }
        version = data[1];
      } else if ((name == 'Chrome' || name != 'IE') && (data = /\bEdge\/([\d.]+)/.exec(ua))) {
        name = 'IE';
        version = data[1];
        layout = ['Trident'];
        description.unshift('platform preview');
      }
      if (useFeatures) {
        if (isHostType(context, 'global')) {
          if (java) {
            data = java.lang.System;
            arch = data.getProperty('os.arch');
            os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
          }
          if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
            os || (os = data[0].os || null);
            try {
              data[1] = context.require('ringo/engine').version;
              version = data[1].join('.');
              name = 'RingoJS';
            } catch (e) {
              if (data[0].global.system == context.system) {
                name = 'Narwhal';
              }
            }
          } else if (typeof context.process == 'object' && (data = context.process)) {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version)[0];
          } else if (rhino) {
            name = 'Rhino';
          }
        } else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
          name = 'Adobe AIR';
          os = data.flash.system.Capabilities.os;
        } else if (getClassOf((data = context.phantom)) == phantomClass) {
          name = 'PhantomJS';
          version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
        } else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
          version = [version, doc.documentMode];
          if ((data = +data[1] + 4) != version[1]) {
            description.push('IE ' + version[1] + ' mode');
            layout && (layout[1] = '');
            version[1] = data;
          }
          version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
        }
        os = os && format(os);
      }
      if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && 'a')) {
        prerelease = /b/i.test(data) ? 'beta' : 'alpha';
        version = version.replace(RegExp(data + '\\+?$'), '') + (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
      }
      if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
        name = 'Firefox Mobile';
      } else if (name == 'Maxthon' && version) {
        version = version.replace(/\.[\d.]+/, '.x');
      } else if (name == 'Silk') {
        if (!/\bMobi/i.test(ua)) {
          os = 'Android';
          description.unshift('desktop mode');
        }
        if (/Accelerated *= *true/i.test(ua)) {
          description.unshift('accelerated');
        }
      } else if (/\bXbox\b/i.test(product)) {
        os = null;
        if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
          description.unshift('mobile mode');
        }
      } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == 'Windows CE' || /Mobi/i.test(ua))) {
        name += ' Mobile';
      } else if (name == 'IE' && useFeatures && context.external === null) {
        description.unshift('platform preview');
      } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] || version)) {
        data = [data, /BB10/.test(ua)];
        os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
        version = null;
      } else if (this != forOwn && (product != 'Wii' && ((useFeatures && opera) || (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) || (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) || (name == 'IE' && ((os && !/^Win/.test(os) && version > 5.5) || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))))) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
        data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
        if (reOpera.test(name)) {
          if (/\bIE\b/.test(data) && os == 'Mac OS') {
            os = null;
          }
          data = 'identify' + data;
        } else {
          data = 'mask' + data;
          if (operaClass) {
            name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
          } else {
            name = 'Opera';
          }
          if (/\bIE\b/.test(data)) {
            os = null;
          }
          if (!useFeatures) {
            version = null;
          }
        }
        layout = ['Presto'];
        description.push(data);
      }
      if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
        if (name == 'Safari' && data[1].slice(-1) == '+') {
          name = 'WebKit Nightly';
          prerelease = 'alpha';
          version = data[1].slice(0, -1);
        } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
          version = null;
        }
        data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
        if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && name != 'IE') {
          layout = ['Blink'];
        }
        if (!useFeatures || (!likeChrome && !data[1])) {
          layout && (layout[1] = 'like Safari');
          data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
        } else {
          layout && (layout[1] = 'like Chrome');
          data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
        }
        layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
        if (name == 'Safari' && (!version || parseInt(version) > 45)) {
          version = data;
        }
      }
      if (name == 'Opera' && (data = /\bzbov|zvav$/.exec(os))) {
        name += ' ';
        description.unshift('desktop mode');
        if (data == 'zvav') {
          name += 'Mini';
          version = null;
        } else {
          name += 'Mobile';
        }
        os = os.replace(RegExp(' *' + data + '$'), '');
      } else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
        description.unshift('desktop mode');
        name = 'Chrome Mobile';
        version = null;
        if (/\bOS X\b/.test(os)) {
          manufacturer = 'Apple';
          os = 'iOS 4.3+';
        } else {
          os = null;
        }
      }
      if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 && ua.indexOf('/' + data + '-') > -1) {
        os = trim(os.replace(data, ''));
      }
      if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
        (data = layout[layout.length - 1]) && description.push(data);
      }
      if (description.length) {
        description = ['(' + description.join('; ') + ')'];
      }
      if (manufacturer && product && product.indexOf(manufacturer) < 0) {
        description.push('on ' + manufacturer);
      }
      if (product) {
        description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
      }
      if (os) {
        data = / ([\d.+]+)$/.exec(os);
        isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
        os = {
          'architecture': 32,
          'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
          'version': data ? data[1] : null,
          'toString': function() {
            var version = this.version;
            return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
          }
        };
      }
      if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
        if (os) {
          os.architecture = 64;
          os.family = os.family.replace(RegExp(' *' + data), '');
        }
        if (name && (/\bWOW64\b/i.test(ua) || (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))) {
          description.unshift('32-bit');
        }
      }
      ua || (ua = null);
      var platform = {};
      platform.description = ua;
      platform.layout = layout && layout[0];
      platform.manufacturer = manufacturer;
      platform.name = name;
      platform.prerelease = prerelease;
      platform.product = product;
      platform.ua = ua;
      platform.version = name && version;
      platform.os = os || {
        'architecture': null,
        'family': null,
        'version': null,
        'toString': function() {
          return 'null';
        }
      };
      platform.parse = parse;
      platform.toString = toStringPlatform;
      if (platform.version) {
        description.unshift(version);
      }
      if (platform.name) {
        description.unshift(name);
      }
      if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
        description.push(product ? '(' + os + ')' : 'on ' + os);
      }
      if (description.length) {
        platform.description = description.join(' ');
      }
      return platform;
    }
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      define(function() {
        return parse();
      });
    } else if (freeExports && freeModule) {
      forOwn(parse(), function(value, key) {
        freeExports[key] = value;
      });
    } else {
      root.platform = parse();
    }
  }.call(this));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9", ["8"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1", ["9", "7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var root = typeof window != 'undefined' ? window : (global || this);
  var Platform = root.platform = req('9');
  var Benchmark = root.Benchmark = req('7');
  java.lang.System.out.println(Benchmark.platform);
  global.define = __define;
  return module.exports;
});

})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else
    factory();
});
//# sourceMappingURL=foo.min.js.map
